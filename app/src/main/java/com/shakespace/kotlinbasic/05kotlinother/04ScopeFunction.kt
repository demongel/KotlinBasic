package com.shakespace.kotlinbasic.`05kotlinother`


/**
 * 作用域函数
 * let
 * run
 * with
 * apply
 * also
 *
 * 区别：
 *  访问上下文对象到方式 --》 this 或者it
 *  返回值
 *
 使用 this
run , with , 和 apply 函数将上下文函数作为 Lambda 表达式的接受者 - 通过 this 关键字来访问.
因此, 在这些函数的 Lambda 表达式 内, 可以向通常的类函数一样访问到上下文对象.
大多数情况下, 访问接受者对象的成员时, 可以省略 this 关键字, 代码可以更简短.
另一 方面, 如果省略了 this , 阅读代码时会很难区分哪些是接受者的成员,
哪些是外部对象和函数. 因此, 把上下文对象作为接受者( this )的方 式,
建议用于那些主要对上下文对象成员进行操作的 Lambda 表达式:
调用上下文对象的函数, 或对其属性赋值.

使用 it
let 和 also 函数使用另一种方式, 它们将上下文对象作为 Lambda 表达式的参数.
如果参数名称不指定, 那么上下文对象使用隐含的默 认参数名称 it .
it 比 this 更短, 而且带 it 的表达式通常也更容易阅读.
但是, 你就不能象省略 this 那样, 隐含地访问访问对象的函数 和属性了.
因此, 把上下文对象作为 it 的方式, 比较适合于对象主要被用作函数参数的情况.
如果你的代码段中存在多个变量, it 也是更 好的选择.


各种作用域函数的区别还包括它们的返回值:
— apply 和 also 函数返回作用域对象.
— let , run , 和 with 函数返回 Lambda 表达式的结果值.

apply 和 also 的返回值是作用域对象本身. 因此它们可以作为 旁路(side step) 成为链式调用的一部分:
你可以在这些函数之后对同一个 对象继续调用其他函数.

let , run , 和 with 函数返回 Lambda 表达式的结果值.
因此, 如果需要将 Lambda 表达式结果赋值给一个变量,
或者对 Lambda 表达式 结果进行链式操作, 等等, 你可以使用这些函数.


DOCs 220 ～223  有详细介绍
下面是根据你的需求来选择作用域函数的简短指南:
— 在非 null 对象上执行 Lambda 表达式: let
— 在一个局部作用域内引入变量: let
— 对一个对象的属性进行设置: apply —对一个对象的属性进行设置,并计算结果值: run —在需要表达式的地方执行多条语句:非扩展函数形式的 run — 对一个对象进行一些附加处理: also
— 对一个对象进行一组函数调用: with

 *
 *
 */
fun main() {

}